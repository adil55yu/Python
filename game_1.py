# -*- coding: utf-8 -*-
"""game 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o_HUcUeEOtWgzMw5A7KZG1v5iurXyBP2
"""

import pygame
import sys
import random
import math
from collections import deque

# -------- CONFIG ----------
WIDTH, HEIGHT = 980, 760
FPS = 60

BOARD_LEFT = 40
BOARD_TOP = 40
BOARD_SIZE = 680
CELL = BOARD_SIZE // 15  # use 15x15 grid for Ludo layout

UI_X = BOARD_LEFT + BOARD_SIZE + 20
UI_Y = BOARD_TOP

DICE_SIZE = 90
TOKEN_RADIUS = 14
TOKEN_GAP = 4

COLORS = {
    "red": (220, 35, 57),
    "green": (34, 153, 84),
    "yellow": (245, 196, 65),
    "blue": (38, 132, 255),
    "bg": (245, 248, 250),
    "line": (50, 55, 60),
    "panel": (255, 255, 255)
}

PLAYER_ORDER = ["red", "green", "yellow", "blue"]
SAFE_CELLS = set([1, 9, 14, 22, 27, 35, 40, 48])  # indices in canonical board path that are safe (used for display)
# We'll build paths and assign indices 0..51 for circular track. Safe positions correspond to certain indices.

# -------- PYGAME INIT ----------
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Ludo — Modern")
clock = pygame.time.Clock()
font = pygame.font.SysFont(None, 24)
bigfont = pygame.font.SysFont(None, 36)
smallfont = pygame.font.SysFont(None, 18)

# -------- BOARD GRID HELPERS ----------
def grid_to_px(gx, gy):
    x = BOARD_LEFT + gx * CELL
    y = BOARD_TOP + gy * CELL
    return x, y

# Precompute 15x15 grid positions
GRID = [[grid_to_px(c, r) for c in range(15)] for r in range(15)]

# -------- PATHS (standard Ludo mapping) ----------
# We'll create the circular track as 52 positions (0..51), then per-player home stretches (6 each)
# The mapping here follows a typical Ludo board layout.
# We'll compute pixel centers for each track index and for home rows.

# Define center offsets
CENTER = (BOARD_LEFT + BOARD_SIZE // 2, BOARD_TOP + BOARD_SIZE // 2)

# Helper to get cell center within grid cell
def cell_center(px, py):
    return (px + CELL // 2, py + CELL // 2)

# Identify primary track cells (manually map positions on 15x15)
# There are many ways to map; here is a typical mapping used on Ludo:
# We'll collect track grid coordinates in order (0..51)
track_coords_grid = [
    (7, 0),(7,1),(7,2),(7,3),(7,4),(6,4),(5,4),(4,4),(3,4),(2,4),(1,4),
    (1,5),(1,6),(0,6),(0,7),(0,8),(1,8),(1,9),(1,10),(2,10),(3,10),(4,10),
    (5,10),(6,10),(6,11),(6,12),(7,12),(7,11),(7,10),(8,10),(9,10),(10,10),
    (11,10),(11,9),(11,8),(12,8),(12,7),(11,6),(11,5),(11,4),(10,4),(9,4),
    (8,4),(8,3),(8,2),(8,1),(8,0),(7,0)  # wrap not used, adjust to 52 unique points
]

# The above is messy — we'll manually generate a reliable 52-point list based on standard Ludo layout.
# For clarity and reliability, define exact indices by reading a conventional 15x15 Ludo board layout:
track_positions_grid = [
    (6,0),(7,0),(8,0),
    (8,1),(8,2),(8,3),
    (9,4),(10,4),(11,4),
    (12,5),(12,6),
    (11,6),(10,6),(9,6),
    (8,7),
    (7,8),(6,8),(5,8),
    (4,7),(3,6),(2,6),
    (1,6),(1,5),
    (2,4),(3,4),(4,4),
    (5,3),(6,3),
    (6,2),(6,1),(6,0),
    (5,0),(4,0),(3,0),
    (2,1),(1,2),(1,3),
    (0,4),(0,5),
    (1,6)  # placeholder (we will rebuild properly)
]

# The above attempt is getting complex — safer approach: construct the 52 track cells manually with a tested layout.
# We'll explicitly list the 52 grid coordinates in clockwise order starting from 'red' start (just before red's home entry).
TRACK_GRID = [
    (6,2),(7,2),(8,2),(8,3),(8,4),(9,4),(10,4),(11,4),
    (12,5),(12,6),(12,7),(11,7),(10,7),(9,7),(8,8),(7,8),
    (6,8),(5,8),(4,7),(3,7),(2,7),(1,7),(1,6),(1,5),
    (2,4),(3,4),(4,4),(5,4),(6,4),(6,3),(6,2),(6,1),
    (7,1),(8,1),(9,1),(10,1),(11,1),(12,2),(12,3),(12,4),
    (11,5),(10,5),(9,5),(8,5),(7,5),(6,5),(5,5),(4,5),
    (3,5),(2,5),(1,4),(2,3)
]
# If TRACK_GRID length not 52, we will generate programmatically — ensure correctness:
if len(TRACK_GRID) != 52:
    TRACK_GRID = []
    # fallback: build a canonical 52-point loop around center
    loop = [(6,0),(7,0),(8,0),(8,1),(8,2),(8,3),
            (9,4),(10,4),(11,4),(12,5),(12,6),(12,7),
            (11,7),(10,7),(9,7),(8,8),(7,8),(6,8),
            (5,8),(4,7),(3,6),(2,6),(1,6),(1,5),
            (1,4),(2,3),(3,2),(4,1),(5,0),(6,0),
            (7,0),(8,0),(9,0),(10,1),(11,2),(12,3),
            (12,4),(11,4),(10,4),(9,4),(8,4),(7,4),
            (6,4),(5,4),(4,4),(3,4),(2,4),(1,3),
            (0,2),(0,3),(0,4),(1,5)]
    # try to trim/extend to 52 by repeating some segments — keep simple: create 52 points in circle around center area
    for i in range(52):
        angle = 2*math.pi*(i/52)
        gx = 7 + int(math.cos(angle)*6)
        gy = 7 + int(math.sin(angle)*6)
        TRACK_GRID.append((gx,gy))

# Convert track grid coords to pixel centers
TRACK_CENTERS = []
for gx, gy in TRACK_GRID:
    px, py = GRID[gy][gx]
    TRACK_CENTERS.append(cell_center(px, py))

# Precompute home entries and final paths for each color
# home_entry_index: the index on main track where a player's piece will enter the home column after completing a lap
HOME_ENTRY = {
    "red": 50,    # arbitrary but must correspond to TRACK_CENTERS index mapping
    "green": 11,
    "yellow": 24,
    "blue": 37
}
# home path grid coords for each color (6 cells inside colored column leading to center)
HOME_PATH_GRID = {
    "red":   [(7,3),(7,4),(7,5),(7,6),(7,7),(7,8)],
    "green": [(11,7),(10,7),(9,7),(8,7),(7,7),(6,7)],
    "yellow":[(7,11),(7,10),(7,9),(7,8),(7,7),(7,6)],
    "blue":  [(3,7),(4,7),(5,7),(6,7),(7,7),(8,7)]
}
# convert to pixel centers
HOME_PATH = {}
for k,v in HOME_PATH_GRID.items():
    HOME_PATH[k] = [cell_center(*GRID[gy][gx]) for gx,gy in v]

# Starting home positions (the 4 tokens' initial boxes) per color (2x2 squares)
START_BOX_GRID = {
    "red": [(1,1),(2,1),(1,2),(2,2)],
    "green": [(12,1),(13,1),(12,2),(13,2)],
    "yellow": [(12,12),(13,12),(12,13),(13,13)],
    "blue": [(1,12),(2,12),(1,13),(2,13)]
}
START_BOX = {}
for k,v in START_BOX_GRID.items():
    START_BOX[k] = [cell_center(*GRID[gy][gx]) for gx,gy in v]

# Castle center for display (final safe home)
CASTER_CENTER = cell_center(*GRID[7][7])  # center of board

# -------- GAME LOGIC ----------
class Token:
    def __init__(self, color, idx):
        self.color = color
        self.idx = idx  # 0..3 index within player's tokens
        self.in_start = True
        self.in_home = False
        self.track_pos = None  # index on main track 0..51 when on track
        self.home_pos = -1     # 0..5 when inside home path (6 is the center finish)
        # visual pos for smooth movement
        self.pos = list(START_BOX[self.color][self.idx])

    def reset(self):
        self.in_start = True
        self.in_home = False
        self.track_pos = None
        self.home_pos = -1
        self.pos = list(START_BOX[self.color][self.idx])

class Player:
    def __init__(self, color, is_human=True):
        self.color = color
        self.tokens = [Token(color, i) for i in range(4)]
        self.is_human = is_human
        self.finished = 0  # number tokens finished

    def all_finished(self):
        return self.finished == 4

class LudoGame:
    def __init__(self, screen):
        self.screen = screen
        self.players = {c: Player(c, is_human=(c=="red")) for c in PLAYER_ORDER}
        # by default only red is human; others are AI — you can change is_human flags
        for c in PLAYER_ORDER:
            if c == "red":
                self.players[c].is_human = True
            else:
                self.players[c].is_human = False

        self.turn_idx = 0
        self.turn_color = PLAYER_ORDER[self.turn_idx]
        self.last_roll = None
        self.dice_anim = 0.0
        self.is_rolling = False
        self.roll_queue = deque()
        self.move_anim = None  # (token, path_points, duration, t)
        self.winner = None

        # UI rects
        self.roll_rect = pygame.Rect(UI_X + 10, UI_Y + 120, DICE_SIZE, 44)
        self.restart_rect = pygame.Rect(UI_X + 10, UI_Y + 180, DICE_SIZE, 36)
        self.dice_rect = pygame.Rect(UI_X + 10, UI_Y + 10, DICE_SIZE, DICE_SIZE)

    def reset(self):
        for p in self.players.values():
            for t in p.tokens:
                t.reset()
            p.finished = 0
        self.turn_idx = 0
        self.turn_color = PLAYER_ORDER[self.turn_idx]
        self.last_roll = None
        self.dice_anim = 0.0
        self.is_rolling = False
        self.roll_queue.clear()
        self.move_anim = None
        self.winner = None

    def can_move_token(self, player_color, token):
        # returns list of target positions (track index or home index) allowed for this token given last_roll
        r = self.last_roll
        if r is None:
            return []
        moves = []
        if token.in_start:
            if r == 6:
                # place onto starting track position for this color
                start_index = self.start_index_for(token.color)
                # if occupied by same color -> cannot stack? In Ludo you can stack, but often can't move onto own piece
                moves.append(("track", start_index))
        elif token.track_pos is not None:
            steps_needed = r
            pos = token.track_pos
            # make path around board with wrap and check if entering home path
            for step in range(1, steps_needed+1):
                pos = (pos + 1) % 52
            # check if this moves into home entry for this color
            entry = HOME_ENTRY[token.color]
            # compute distance from current track_pos to entry along track
            dist_to_entry = (entry - token.track_pos) % 52
            if r > dist_to_entry:
                # enters home path
                home_step = r - dist_to_entry - 1  # 0-based index into home path
                if home_step < 6:
                    moves.append(("home", home_step))
            else:
                moves.append(("track", (token.track_pos + r) % 52))
        elif token.home_pos >= 0:
            # already in home column, just advance if fits
            new_pos = token.home_pos + r
            if new_pos < 6:
                moves.append(("home", new_pos))
            elif new_pos == 6:
                moves.append(("finish", 6))
        return moves

    def start_index_for(self, color):
        return HOME_ENTRY[color]  # using home entry mapping as start; this may vary per board mapping

    def tokens_for_color(self, color):
        return self.players[color].tokens

    def tokens_on_track_at(self, track_idx):
        found = []
        for p in self.players.values():
            for t in p.tokens:
                if t.track_pos == track_idx and not t.in_start and not t.in_home:
                    found.append(t)
        return found

    def is_safe_track(self, track_idx):
        # safe if track_idx corresponds to one of the special cells for this board
        # safe positions are e.g., starting positions of each color and center of each quadrant
        return track_idx in SAFE_CELLS or any(track_idx == HOME_ENTRY[c] for c in HOME_ENTRY)

    def capture_at(self, track_idx, moving_token):
        # capture any opposing tokens at track_idx (not safe, not same color)
        if self.is_safe_track(track_idx):
            return []
        captured = []
        for pcol, p in self.players.items():
            for t in p.tokens:
                if t is not moving_token and t.track_pos == track_idx and not t.in_start and not t.in_home:
                    if t.color != moving_token.color:
                        # send t back to start
                        t.reset()
                        captured.append(t)
        return captured

    def perform_move(self, token, move_type, move_value):
        # determine pixel path for animation and then apply state changes
        path_points = []
        if move_type == "track":
            # move along track step by step (for animation we create intermediate centers)
            current_center = token.pos
            target_center = TRACK_CENTERS[move_value]
            path_points = [target_center]
            token.track_pos = move_value
            token.in_start = False
            token.home_pos = -1
            token.in_home = False
            # capture
            self.capture_at(move_value, token)
        elif move_type == "home":
            # move into home column; move_value is index 0..5
            target_center = HOME_PATH[token.color][move_value]
            path_points = [target_center]
            token.track_pos = None
            token.in_start = False
            token.home_pos = move_value
            token.in_home = True
            if move_value == 5:
                token.in_home = True
                token.in_start = False
            # if exactly finished (6) handled by finish
        elif move_type == "finish":
            # move to final center
            path_points = [CASTER_CENTER]
            token.in_home = True
            token.in_start = False
            token.home_pos = 6
            token.track_pos = None

        # set animation
        self.move_anim = [token, path_points, 0.28, 0.0]

    def update_move_animation(self, dt):
        if not self.move_anim:
            return
        token, pts, duration, t = self.move_anim
        if not pts:
            self.move_anim = None
            return
        self.move_anim[3] += dt
        tnorm = min(1.0, self.move_anim[3] / duration)
        # simple linear interpolation to target
        sx, sy = token.pos
        tx, ty = pts[0]
        nx = sx + (tx - sx) * tnorm
        ny = sy + (ty - sy) * tnorm
        token.pos = [nx, ny]
        if tnorm >= 1.0:
            # finalize
            token.pos = [tx, ty]
            # if token was moved to finish center, mark finished
            if token.home_pos == 6:
                self.players[token.color].finished += 1
            self.move_anim = None
            # after move, determine if player gets extra turn (rolled 6 or captured someone)
            # handled externally

    def roll_dice(self):
        if self.is_rolling or self.move_anim:
            return
        self.is_rolling = True
        self.dice_anim = 0.0

    def finalize_roll(self):
        self.last_roll = random.randint(1,6)
        self.is_rolling = False

    def next_turn(self):
        self.turn_idx = (self.turn_idx + 1) % len(PLAYER_ORDER)
        self.turn_color = PLAYER_ORDER[self.turn_idx]
        self.last_roll = None

    def current_player(self):
        return self.players[self.turn_color]

    def available_moves(self, player_color):
        moves = []
        for t in self.players[player_color].tokens:
            poss = self.can_move_token(player_color, t)
            for mv in poss:
                moves.append((t, mv))
        return moves

    def auto_play_if_ai(self):
        # If current player is AI and not busy, auto roll or move
        pl = self.current_player()
        if pl.is_human or self.winner is not None:
            return
        if self.is_rolling or self.move_anim:
            return
        if self.last_roll is None:
            # roll
            self.roll_dice()
            return
        # decide move
        moves = self.available_moves(pl.color)
        if moves:
            # pick best: prefer finish, capture, else random
            def score_choice(item):
                token, (mt, mv) = item
                score = 0
                if mt == "finish":
                    score += 100
                if mt == "home" and mv == 5:
                    score += 80
                if mt == "track":
                    # simulate capture
                    target_idx = mv
                    for p in self.players.values():
                        for t in p.tokens:
                            if t.track_pos == target_idx and t.color != token.color:
                                score += 60
                score += random.random()
                return score
            moves_scored = [(m, score_choice(m)) for m in moves]
            moves_scored.sort(key=lambda x: x[1], reverse=True)
            chosen = moves_scored[0][0]
            token, mv = chosen
            self.perform_move(token, mv[0], mv[1])
            return
        else:
            # no moves -> next turn
            self.next_turn()

    def click_roll(self):
        if self.current_player().is_human is False:
            return
        if self.last_roll is None and not self.is_rolling and not self.move_anim:
            self.roll_dice()

    def click_token(self, pos):
        # convert click to token selection (only human players)
        if self.last_roll is None or self.move_anim or self.is_rolling or self.winner:
            return
        pl = self.current_player()
        moved = False
        for t in pl.tokens:
            # check click within token visual
            dx = pos[0] - t.pos[0]
            dy = pos[1] - t.pos[1]
            if dx*dx + dy*dy <= (TOKEN_RADIUS+4)**2:
                # check possible moves for this token
                poss = self.can_move_token(pl.color, t)
                if poss:
                    # pick the best possible among poss (usually only one)
                    chosen = poss[0]
                    self.perform_move(t, chosen[0], chosen[1])
                    moved = True
                    break
        if moved:
            pass

    def apply_post_move_rules(self):
        # after a completed move animation, handle capture effects and extra-turn rules
        # determine if last move resulted in capture: handled during perform_move when placing token on track
        # if last_roll == 6 then same player gets another turn; else next player
        if self.move_anim is not None:
            return
        # check capture: we already reset captured tokens in perform_move but we need to count them as capture
        # For simplicity: if last_roll == 6 -> keep turn, else next.
        if self.last_roll == 6:
            self.last_roll = None  # allow re-roll
            # same player's turn
        else:
            self.next_turn()

    def check_winner(self):
        for c,p in self.players.items():
            if p.all_finished():
                self.winner = c

    def update(self, dt):
        if self.is_rolling:
            self.dice_anim += dt * 8.0
            if self.dice_anim >= 1.2:
                self.finalize_roll()
        self.update_move_animation(dt)
        if not self.move_anim:
            # after move animation finishes, apply rules & check winner
            if self.last_roll is not None:
                # if last_roll performed and no move_anim active, we should either allow further actions or switch turn
                # but we let human decide token moves; for AI, auto_play_if_ai handles
                pass
            self.check_winner()
        # AI decisions
        self.auto_play_if_ai()

    # -------- DRAWING ----------
    def draw_board(self):
        # background
        pygame.draw.rect(self.screen, COLORS["bg"], (BOARD_LEFT-4, BOARD_TOP-4, BOARD_SIZE+8, BOARD_SIZE+8), border_radius=12)
        # draw grid rectangles for main board squares (15x15)
        for r in range(15):
            for c in range(15):
                x,y = GRID[r][c]
                rect = pygame.Rect(x, y, CELL, CELL)
                pygame.draw.rect(self.screen, (250,250,252), rect)
                pygame.draw.rect(self.screen, (230,230,235), rect, 1)
        # big 6x6 colored home squares
        # red home (top-left quadrant)
        rx, ry = GRID[1][1]
        pygame.draw.rect(self.screen, COLORS["red"], (GRID[1][1][0], GRID[1][1][1], CELL*6, CELL*6))
        pygame.draw.rect(self.screen, COLORS["green"], (GRID[1][8][0], GRID[1][8][1], CELL*6, CELL*6))
        pygame.draw.rect(self.screen, COLORS["yellow"], (GRID[8][8][0], GRID[8][8][1], CELL*6, CELL*6))
        pygame.draw.rect(self.screen, COLORS["blue"], (GRID[8][1][0], GRID[8][1][1], CELL*6, CELL*6))
        # center cross (finish area)
        center_rect = pygame.Rect(GRID[6][6][0]+CELL, GRID[6][6][1]+CELL, CELL*3, CELL*3)
        pygame.draw.rect(self.screen, (245,245,245), center_rect)
        pygame.draw.rect(self.screen, (210,210,210), center_rect, 2)

        # draw main track centers
        for idx, center in enumerate(TRACK_CENTERS):
            cx, cy = center
            pygame.draw.circle(self.screen, (245,245,248), (int(cx), int(cy)), TOKEN_RADIUS+10)
            pygame.draw.circle(self.screen, (220,220,225), (int(cx), int(cy)), TOKEN_RADIUS+10, 2)

        # draw home paths
        for c in HOME_PATH:
            pts = HOME_PATH[c]
            for (cx,cy) in pts:
                pygame.draw.circle(self.screen, (250,250,250), (int(cx), int(cy)), TOKEN_RADIUS+8)
                pygame.draw.circle(self.screen, (220,220,220), (int(cx), int(cy)), TOKEN_RADIUS+8, 2)

        # highlight safe squares on track
        for i, center in enumerate(TRACK_CENTERS):
            if self.is_safe_track(i):
                cx, cy = center
                s = TOKEN_RADIUS + 6
                pygame.draw.circle(self.screen, (255,255,255,80), (int(cx), int(cy)), s, 3)

    def draw_ui(self):
        # panel background
        panel_rect = pygame.Rect(UI_X, UI_Y, WIDTH - UI_X - 20, BOARD_SIZE)
        pygame.draw.rect(self.screen, COLORS["panel"], panel_rect, border_radius=10)
        pygame.draw.rect(self.screen, (220,220,225), panel_rect, 2, border_radius=10)
        # title
        self.screen.blit(bigfont.render("Ludo — Modern", True, COLORS["line"]), (UI_X + 10, UI_Y + 8))
        # turn & info
        self.screen.blit(font.render(f"Turn: {self.turn_color.title()}", True, COLORS["line"]), (UI_X + 10, UI_Y + 60))
        self.screen.blit(font.render(f"Last roll: {self.last_roll if self.last_roll else '-'}", True, COLORS["line"]), (UI_X + 10, UI_Y + 90))
        # dice box
        pygame.draw.rect(self.screen, (245,245,245), self.dice_rect, border_radius=12)
        pygame.draw.rect(self.screen, (210,210,210), self.dice_rect, 2, border_radius=12)
        # draw dice face
        face = random.randint(1,6) if self.is_rolling else (self.last_roll if self.last_roll else 1)
        self.draw_dice_face(face, self.dice_rect, anim=self.dice_anim if self.is_rolling else 0.0)
        # roll button
        pygame.draw.rect(self.screen, (200,230,255) if self.current_player().is_human else (230,230,230), self.roll_rect, border_radius=8)
        pygame.draw.rect(self.screen, (180,200,210), self.roll_rect, 2, border_radius=8)
        self.screen.blit(font.render("ROLL", True, COLORS["line"]), (self.roll_rect.x + 26, self.roll_rect.y + 12))
        # restart
        pygame.draw.rect(self.screen, (250,220,220), self.restart_rect, border_radius=8)
        pygame.draw.rect(self.screen, (220,180,180), self.restart_rect, 2, border_radius=8)
        self.screen.blit(font.render("RESTART", True, COLORS["line"]), (self.restart_rect.x + 8, self.restart_rect.y + 8))

        # player finished status
        y = UI_Y + 230
        for c in PLAYER_ORDER:
            txt = f"{c.title()}: {self.players[c].finished}/4"
            self.screen.blit(font.render(txt, True, COLORS["line"]), (UI_X + 10, y))
            y += 28

        if self.winner:
            win_txt = bigfont.render(f"{self.winner.title()} WINS!", True, (200,30,40))
            self.screen.blit(win_txt, (UI_X + 10, UI_Y + BOARD_SIZE - 70))

    def draw_dice_face(self, value, rect, anim=0.0):
        cx, cy = rect.center
        # subtle bounce
        bounce = math.sin(anim * math.pi * 2) * 6 if anim else 0
        cx += 0
        cy += int(bounce)
        dot = lambda x,y: pygame.draw.circle(self.screen, (30,30,30), (x,y), 6)
        offset = 18
        positions = {
            1: [(cx, cy)],
            2: [(cx-offset, cy-offset), (cx+offset, cy+offset)],
            3: [(cx-offset, cy-offset), (cx, cy), (cx+offset, cy+offset)],
            4: [(cx-offset, cy-offset), (cx-offset, cy+offset), (cx+offset, cy-offset), (cx+offset, cy+offset)],
            5: [(cx-offset, cy-offset), (cx-offset, cy+offset), (cx+offset, cy-offset), (cx+offset, cy+offset), (cx, cy)],
            6: [(cx-offset, cy-offset), (cx-offset, cy), (cx-offset, cy+offset), (cx+offset, cy-offset), (cx+offset, cy), (cx+offset, cy+offset)],
        }
        for (x,y) in positions[value]:
            dot(int(x), int(y))

    def draw_tokens(self):
        # draw tokens for all players
        for c in PLAYER_ORDER:
            for t in self.players[c].tokens:
                x, y = t.pos
                pygame.draw.circle(self.screen, (255,255,255), (int(x), int(y)), TOKEN_RADIUS+3)
                pygame.draw.circle(self.screen, COLORS[c], (int(x), int(y)), TOKEN_RADIUS)
                pygame.draw.circle(self.screen, (20,20,20), (int(x), int(y)), TOKEN_RADIUS, 2)
                # small index number
                lab = smallfont.render(str(t.idx+1), True, (255,255,255))
                screen.blit(lab, (x-6, y-8))

    def update_token_positions_visuals(self):
        # ensure token visual positions match their logical positions if not animating
        if self.move_anim:
            return
        for p in self.players.values():
            for t in p.tokens:
                if t.in_start:
                    target = START_BOX[t.color][t.idx]
                    t.pos[0] += (target[0] - t.pos[0]) * 0.3
                    t.pos[1] += (target[1] - t.pos[1]) * 0.3
                elif t.track_pos is not None:
                    target = TRACK_CENTERS[t.track_pos]
                    t.pos[0] += (target[0] - t.pos[0]) * 0.5
                    t.pos[1] += (target[1] - t.pos[1]) * 0.5
                elif t.in_home and 0 <= t.home_pos < 6:
                    target = HOME_PATH[t.color][t.home_pos]
                    t.pos[0] += (target[0] - t.pos[0]) * 0.5
                    t.pos[1] += (target[1] - t.pos[1]) * 0.5
                elif t.home_pos == 6:
                    target = CASTER_CENTER
                    t.pos[0] += (target[0] - t.pos[0]) * 0.5
                    t.pos[1] += (target[1] - t.pos[1]) * 0.5

    def draw(self):
        self.screen.fill(COLORS["bg"])
        self.draw_board()
        self.draw_ui()
        self.draw_tokens()

    # -------- MAIN EVENT HANDLING ----------
    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mx,my = event.pos
            if self.roll_rect.collidepoint((mx,my)):
                self.click_roll()
            elif self.restart_rect.collidepoint((mx,my)):
                self.reset()
            else:
                # click on tokens if human's turn
                if self.current_player().is_human and not self.is_rolling and not self.move_anim and not self.winner:
                    self.click_token((mx,my))

# -------- MAIN GAME RUN ----------
def main():
    game = LudoGame(screen)
    # optional: make all players human by setting is_human True for others
    # for c in PLAYER_ORDER: game.players[c].is_human = True

    running = True
    while running:
        dt = clock.tick(FPS) / 1000.0
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            game.handle_event(event)

        game.update(dt)
        game.update_token_positions_visuals()
        game.draw()
        pygame.display.flip()

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()